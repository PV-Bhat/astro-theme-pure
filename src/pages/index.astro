---
import { Image } from 'astro:assets'
import PageLayout from '@/layouts/BaseLayout.astro'
import IntegrationCard from '@/components/home/IntegrationCard.astro'
import GradientText from '@/components/ui/GradientText.astro'
import config from '@/site-config'
import '../styles/animations.css'
import '../styles/glass.css'

// Define the navigation items
const navigationItems = [
  {
    href: "/about",
    title: "About",
    logo: "/navigation-icons/user.svg",
    primaryColor: "169, 169, 169", // Silver
    secondaryColor: "120, 120, 120" // Darker silver
  },
  {
    href: "/blog",
    title: "Blog",
    logo: "/navigation-icons/blog.svg",
    primaryColor: "52, 211, 153", // Green
    secondaryColor: "16, 185, 129" // Teal
  },
  {
    href: "/projects",
    title: "Projects",
    logo: "/navigation-icons/projects.svg",
    primaryColor: "56, 189, 248", // Jean blue
    secondaryColor: "14, 165, 233" // Darker blue
  },
  {
    href: "/docs",
    title: "Docs",
    logo: "/navigation-icons/docs.svg",
    primaryColor: "139, 92, 246", // Purple
    secondaryColor: "124, 58, 237" // Darker purple
  },
  {
    href: "/archives",
    title: "Archives",
    logo: "/navigation-icons/archives.svg",
    primaryColor: "249, 115, 22", // Orange
    secondaryColor: "234, 88, 12" // Darker orange
  },
  {
    href: "/links",
    title: "Links",
    logo: "/navigation-icons/links.svg",
    primaryColor: "236, 72, 153", // Pink
    secondaryColor: "219, 39, 119" // Darker pink
  }
]

// Social links for the minimal header icons
const socialLinks = [
  {
    href: "https://github.com/yourusername",
    label: "GitHub",
    icon: "github"
  },
  {
    href: "https://twitter.com/yourusername",
    label: "Twitter",
    icon: "twitter"
  },
  {
    href: "https://linkedin.com/in/yourusername",
    label: "LinkedIn",
    icon: "linkedin"
  }
]
---

<style>
  /* Pitch black to dark grey gradient background */
  :global(body) {
    background: linear-gradient(to bottom, #000000, #121212);
  }
  
  /* Network node and connection styles */
  .network-container {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
  }
  
  .node {
    position: absolute;
    width: 3px;
    height: 3px;
    background-color: rgba(169, 169, 169, 0.6);
    border-radius: 50%;
    opacity: 0.3;
    transition: transform 0.3s ease-out, opacity 0.3s ease-out, background-color 0.3s ease;
    box-shadow: 0 0 2px rgba(169, 169, 169, 0.2);
  }
  
  .node.active {
    opacity: 0.8;
    width: 4px;
    height: 4px;
    background-color: rgba(169, 169, 169, 0.8);
    box-shadow: 0 0 6px rgba(169, 169, 169, 0.4);
  }
  
  .connection {
    position: absolute;
    height: 1px;
    background: linear-gradient(90deg, 
      rgba(169, 169, 169, 0) 0%, 
      rgba(169, 169, 169, 0.3) 50%, 
      rgba(169, 169, 169, 0) 100%
    );
    transform-origin: 0 0;
    opacity: 0.2;
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 0;
  }
  
  .connection.active {
    opacity: 0.5;
    height: 1.5px;
  }
  
  /* Social icons with vibrant hover effects */
  .social-icon {
    filter: drop-shadow(0 0 3px rgba(169, 169, 169, 0));
    transition: all 0.2s var(--ease-snap);
    position: relative;
    z-index: 1;
  }
  
  .social-icon:hover {
    filter: drop-shadow(0 0 5px rgba(169, 169, 169, 0.5));
    transform: translateY(-2px);
  }
  
  /* Different colors for each social icon */
  .social-icon:nth-child(1):hover {
    color: rgba(56, 189, 248, 1); /* Blue */
  }
  
  .social-icon:nth-child(2):hover {
    color: rgba(236, 72, 153, 1); /* Pink */
  }
  
  .social-icon:nth-child(3):hover {
    color: rgba(52, 211, 153, 1); /* Green */
  }
  
  /* Enhanced navigation cards container - moved higher */
  .nav-container {
    margin-top: 0.5rem;
  }
  
  @media (min-width: 768px) {
    .nav-container {
      transform: scale(1.05);
    }
  }
  
  /* Dynamic background effect with vibrant gradients */
  .dynamic-gray-effect {
    position: absolute;
    inset: 0;
    overflow: hidden;
    z-index: 0;
    opacity: 1;
    background: radial-gradient(circle at 50% 50%, #181820, #000);
    filter: contrast(1.15);
  }
  
  .gradient-orb {
    position: absolute;
    border-radius: 50%;
    filter: blur(100px);
    transition: all 2s cubic-bezier(0.19, 1, 0.22, 1);
    mix-blend-mode: soft-light;
  }
  
  .orb-1 {
    top: 0%;
    left: 5%;
    width: 110vw;
    height: 110vw;
    background: radial-gradient(circle, 
      rgba(66, 199, 258, 0.2) 0%,
      transparent 70%
    );
    animation: float-slow 20s ease-in-out infinite;
    opacity: 0.85;
  }
  
  .orb-2 {
    bottom: -5%;
    right: 5%;
    width: 100vw;
    height: 100vw;
    background: radial-gradient(circle, 
      rgba(62, 221, 163, 0.15) 0%,
      transparent 70%
    );
    animation: float-slow 18s ease-in-out infinite reverse;
    opacity: 0.8;
  }
  
  .orb-3 {
    top: 50%;
    left: 50%;
    width: 140vw;
    height: 140vw;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, 
      rgba(159, 122, 246, 0.1) 0%,
      rgba(86, 194, 245, 0.05) 40%,
      transparent 80%
    );
    animation: pulse-slow 20s ease-in-out infinite;
    opacity: 0.6;
    filter: blur(130px);
  }
  
  .orb-4 {
    top: 20%;
    right: -25%;
    width: 90vw;
    height: 90vw;
    background: radial-gradient(circle, 
      rgba(236, 82, 163, 0.1) 0%,
      rgba(86, 194, 245, 0.03) 50%,
      transparent 70%
    );
    animation: float-slow 25s ease-in-out infinite 5s;
    opacity: 0.7;
    filter: blur(120px);
  }
  
  @keyframes float-slow {
    0%, 100% {
      transform: translateY(0) translateX(0) rotate(0deg);
    }
    25% {
      transform: translateY(-6%) translateX(6%) rotate(3deg);
    }
    50% {
      transform: translateY(6%) translateX(10%) rotate(0deg);
    }
    75% {
      transform: translateY(12%) translateX(-6%) rotate(-3deg);
    }
  }
  
  @keyframes pulse-slow {
    0%, 100% {
      opacity: 0.6;
      filter: blur(130px);
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      opacity: 0.4;
      filter: blur(150px);
      transform: translate(-50%, -50%) scale(1.1);
    }
  }
</style>

<PageLayout meta={{ title: config.title, description: config.description }}>
  <div class="min-h-screen flex flex-col items-center justify-start pt-16 md:pt-24 pb-12 relative overflow-hidden" id="hero-container">
    <!-- Network graph background -->
    <div class="network-container absolute inset-0 w-full h-full z-0" id="network">
      <!-- Nodes and connections will be generated by JavaScript -->
    </div>
    
    <!-- Fallback dynamic gray effect (visible if network effect fails) -->
    <div class="dynamic-gray-effect">
      <div class="gradient-orb orb-1"></div>
      <div class="gradient-orb orb-2"></div>
      <div class="gradient-orb orb-3"></div>
      <div class="gradient-orb orb-4"></div>
    </div>
    
    <!-- Main content -->
    <div class="z-10 flex flex-col items-center w-full max-w-4xl px-4 mx-auto">
      <!-- Hero name with silver effect -->
      <div class="text-center mb-6">
        <h1 class="text-5xl sm:text-7xl font-bold text-center relative mb-4">
          <GradientText
            as="span"
            gradient="multi-color"
            from="#6366f1"
            via="#4ade80"
            to="#ec4899"
            animated={true}
            class="leading-tight tracking-tight font-extrabold"
          >
            Pruthvi Bhat
          </GradientText>
        </h1>
        
        <p class="text-lg mb-4 max-w-xl mx-auto">
          <GradientText
            as="span"
            gradient="custom"
            from="rgba(220, 220, 240, 0.9)"
            to="rgba(180, 180, 200, 0.85)"
            class="font-medium"
          >
            Exploring innovative solutions through design and technology
          </GradientText>
        </p>
        
        <!-- Minimal social links -->
        <div class="flex justify-center gap-5 mt-3">
          {socialLinks.map(link => (
            <a 
              href={link.href}
              target="_blank"
              rel="noopener noreferrer"
              class="text-gray-400 social-icon"
              aria-label={link.label}
            >
              <svg 
                class="w-4 h-4 sm:w-5 sm:h-5"
                fill="currentColor" 
                viewBox="0 0 24 24" 
                aria-hidden="true"
              >
                {link.icon === 'github' && 
                  <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd" />
                }
                {link.icon === 'twitter' && 
                  <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84" />
                }
                {link.icon === 'linkedin' && 
                  <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452z" />
                }
              </svg>
            </a>
          ))}
        </div>
      </div>
      
      <!-- Navigation cards - moved higher -->
      <div class="nav-container w-full">
        <ul class="mx-auto grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3 sm:gap-4 w-max">
          {navigationItems.map(item => (
            <IntegrationCard
              href={item.href}
              title={item.title}
              logo={item.logo}
              primaryColor={item.primaryColor}
              secondaryColor={item.secondaryColor}
            />
          ))}
        </ul>
      </div>
    </div>
  </div>
</PageLayout>

<script>
  // Define types outside of the DOMContentLoaded event
  interface NetworkNode {
    element: HTMLElement;
    x: number;
    y: number;
    vx: number;
    vy: number;
    speed: number;
    size: number;
  }
  
  interface Connection {
    element: HTMLElement;
    nodeA: NetworkNode;
    nodeB: NetworkNode;
  }

  // Network graph animation with Obsidian-like behavior
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('hero-container') as HTMLElement;
    const network = document.getElementById('network') as HTMLElement;
    
    if (!container || !network) {
      console.error('Network animation container not found');
      return;
    }
    
    try {
      // Settings
      const nodeCount = 40; // Number of nodes
      const connectionDistance = 150; // Maximum distance for connections
      const nodeSize = { min: 2, max: 4 }; // Node size range
      const moveSpeed = { min: 0.3, max: 0.8 }; // Movement speed range
      const acceleration = 4; // How much to speed up around cursor
      const initialOpacity = { min: 0.1, max: 0.3 }; // Initial opacity range
      
      // Create nodes
      const nodes: NetworkNode[] = [];
      const connections: Connection[] = [];
      let mouseX: number | null = null;
      let mouseY: number | null = null;
      let animationFrame: number | null = null;
      
      // Create initial nodes
      for (let i = 0; i < nodeCount; i++) {
        createNode(nodes, container, network);
      }
      
      // Update connections on animation frame
      function updateConnections() {
        // Remove existing connections
        connections.forEach(conn => {
          if (conn.element && conn.element.parentNode) {
            conn.element.remove();
          }
        });
        connections.length = 0;
        
        // Create new connections
        for (let i = 0; i < nodes.length; i++) {
          const nodeA = nodes[i];
          
          for (let j = i + 1; j < nodes.length; j++) {
            const nodeB = nodes[j];
            const distance = Math.hypot(nodeB.x - nodeA.x, nodeB.y - nodeA.y);
            
            if (distance < connectionDistance) {
              // Create connection element
              const connection = document.createElement('div');
              connection.className = 'connection';
              
              // Calculate position and length
              const angle = Math.atan2(nodeB.y - nodeA.y, nodeB.x - nodeA.x);
              const opacity = Math.max(0, 1 - distance / connectionDistance) * 0.3;
              
              // Apply styles
              connection.style.width = `${distance}px`;
              connection.style.left = `${nodeA.x}px`;
              connection.style.top = `${nodeA.y}px`;
              connection.style.transform = `rotate(${angle}rad)`;
              connection.style.opacity = `${opacity}`;
              
              // Add to DOM and store reference
              network.appendChild(connection);
              connections.push({ 
                element: connection, 
                nodeA: nodeA, 
                nodeB: nodeB
              });
              
              // Add active class if near cursor
              if (mouseX !== null && mouseY !== null) {
                const toMouseA = Math.hypot(mouseX - nodeA.x, mouseY - nodeA.y);
                const toMouseB = Math.hypot(mouseX - nodeB.x, mouseY - nodeB.y);
                
                if (toMouseA < 150 || toMouseB < 150) {
                  connection.classList.add('active');
                }
              }
            }
          }
        }
      }
      
      // Update all nodes and connections
      function updateNetwork() {
        // Update node positions
        nodes.forEach(node => {
          // Calculate base movement
          node.x += node.vx;
          node.y += node.vy;
          
          // Boundary check and bounce
          if (node.x <= 0 || node.x >= container.offsetWidth) {
            node.vx *= -1;
            node.x = Math.max(0, Math.min(node.x, container.offsetWidth));
          }
          
          if (node.y <= 0 || node.y >= container.offsetHeight) {
            node.vy *= -1;
            node.y = Math.max(0, Math.min(node.y, container.offsetHeight));
          }
          
          // Apply cursor influence
          if (mouseX !== null && mouseY !== null) {
            const dx = mouseX - node.x;
            const dy = mouseY - node.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance < 200) {
              // Calculate influence based on proximity
              const influence = Math.max(0, 1 - distance / 200);
              
              // Add acceleration in direction toward cursor
              node.vx += (dx / distance) * influence * 0.05;
              node.vy += (dy / distance) * influence * 0.05;
              
              // Cap max speed
              const currentSpeed = Math.hypot(node.vx, node.vy);
              if (currentSpeed > node.speed * acceleration) {
                node.vx = (node.vx / currentSpeed) * node.speed * acceleration;
                node.vy = (node.vy / currentSpeed) * node.speed * acceleration;
              }
              
              // Activate node near cursor
              if (distance < 100) {
                node.element.classList.add('active');
              } else {
                node.element.classList.remove('active');
              }
            } else {
              // Return to normal speed gradually
              const currentSpeed = Math.hypot(node.vx, node.vy);
              if (currentSpeed > node.speed) {
                node.vx = node.vx * 0.98;
                node.vy = node.vy * 0.98;
              }
              node.element.classList.remove('active');
            }
          }
          
          // Update element position
          node.element.style.transform = `translate(${node.x}px, ${node.y}px)`;
        });
        
        // Update connections
        updateConnections();
        
        // Continue animation
        animationFrame = requestAnimationFrame(updateNetwork);
      }
      
      // Start animation
      updateNetwork();
      
      // Track mouse position
      container.addEventListener('mousemove', (e) => {
        const rect = container.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
      });
      
      container.addEventListener('mouseleave', () => {
        mouseX = null;
        mouseY = null;
      });
      
      // Initialize cards animation with a more dynamic approach
      const cards = document.querySelectorAll<HTMLElement>('.nav-container li');
      
      // Prepare cards with initial state
      cards.forEach((card) => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(15px) scale(0.95)';
        card.style.transition = 'all 0.2s cubic-bezier(0.19, 1, 0.22, 1)';
      });
      
      // Define a snappier staggered animation sequence
      const baseDelay = 30; // ms - faster initial delay
      const staggerDelay = 25; // ms - faster stagger between cards
      
      // Function to get a small random offset for slightly varied timings
      const getRandomOffset = () => Math.random() * 10 - 5; // -5 to +5ms
      
      // Apply animation with snappier timing
      cards.forEach((card, index) => {
        setTimeout(() => {
          card.style.opacity = '1';
          card.style.transform = 'translateY(0) scale(1)';
          
          // Add subtle bounce effect after appearing
          setTimeout(() => {
            card.style.transform = 'translateY(-3px) scale(1.02)';
            
            setTimeout(() => {
              card.style.transform = 'translateY(0) scale(1)';
            }, 120);
          }, 120);
        }, baseDelay + (index * staggerDelay) + getRandomOffset());
      });
      
      // Clean up on unmount
      return () => {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
      };
    } catch (error) {
      console.error('Error initializing network animation:', error);
    }
  });
  
  // Create a new node with random position and velocity
  function createNode(nodes: NetworkNode[], container: HTMLElement, network: HTMLElement): NetworkNode {
    const node = document.createElement('div');
    node.className = 'node';
    
    // Random position
    const x = Math.random() * container.offsetWidth;
    const y = Math.random() * container.offsetHeight;
    
    // Random speed and direction
    const speed = 0.3 + Math.random() * 0.5; // Base speed
    const angle = Math.random() * Math.PI * 2;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    
    // Random size
    const size = 2 + Math.random() * 2;
    node.style.width = `${size}px`;
    node.style.height = `${size}px`;
    node.style.opacity = `${0.1 + Math.random() * 0.2}`;
    
    // Position the node
    node.style.transform = `translate(${x}px, ${y}px)`;
    
    // Add to DOM
    network.appendChild(node);
    
    // Store node data
    const nodeObject: NetworkNode = {
      element: node,
      x: x,
      y: y,
      vx: vx,
      vy: vy,
      speed: speed,
      size: size
    };
    
    nodes.push(nodeObject);
    
    return nodeObject;
  }
</script>
